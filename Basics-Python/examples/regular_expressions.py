# Пример 1. Решим простую задачу валидации данных. Пользователь должен ввести своё имя с большой буквы,
# допустимы только русские буквы. Попробуем вариант с множеством / это не регулярные выражения:

# valid_letters = {chr(sym_code) for sym_code in range(ord('а'), ord('я') + 1)}
# valid_letters.add('ё')
# #print(valid_letters)
#
# def name_is_valid(name):
#     if not name or set(name.lower()) - set(valid_letters):
#         return False
#     return name.istitle()
#
#
# if __name__ == '__main__':
#     while True:
#         name = input('Введите имя:\n')
#         if name_is_valid(name):
#             break
#     print(f'пользователь: {name}')

# Теперь решим задачу при помощи регулярного выражения и модуля re:

# import re
#
# RE_NAME = re.compile(r'^[А-ЯЁ][а-яё]+$')   # слово точно должно соответсвовать требованиям, буква заглавные и строчные
#                                            # кирилицей, один или несколько символов, первая буква заглавная
#
# def name_is_valid(name):
#     return RE_NAME.match(name)
#
#
# if __name__ == '__main__':
#     while True:
#         name = input('Введите имя:\n')
#         if name_is_valid(name):
#             break
#     print(f'пользователь: {name}')

# Пример 2. Попробуем написать «регулярку» для валидации даты в формате «ДД.ММ.ГГГГ»:
# import re
#
# RE_DATE = re.compile(r'^(\d{2}\.){2}\d{4}$')     # паттерн “<число><число><разделитель>”, поймали его как группу “(\d{2}\.)” и взяли её дважды “{2}”.
# for date in ['23.01.2021', '23,01,2021', '23~01~2021']:
#     assert RE_DATE.match(date), f'wrong date {date}'   # Будет выдана ошибка
#     #print(RE_DATE.match(date))

# А если понадобится искать даты с другими разделителями: вида “23-01-2021” или “23/01/2021”?
#
# import re
#
# RE_DATE = re.compile(r'^(\d{2}[./-]){2}\d{4}$')   # здесь в качестве разделителей будут . или / или -
# for date in ['23.01.2021', '23/01/2021', '23-01-2021']:
#     assert RE_DATE.match(date), f'wrong date {date}'

# # Пример 2.
# import re
#
# RE_DATE = re.compile(r'(?:\d{2}[./-]){2}\d{4}')
#
# txt = 'Погода 23.01.2021 была отличная! Зато за день до этого (22/01/2021) - очень холодно. ' \
#     'Надеемся, что 24-01-2021 будет без ветра.'
# print(RE_DATE.findall(txt))

# Пример 3. Есть текст с данными о товарах пользователя. Известно, что название товара обёрнуто в кавычки, а его цена
# идет после названия в круглых скобках (между ними может быть пробел, табуляция или даже несколько пробелов). Нужно
# получить список кортежей вида (<название товара>, <цена>):

# import re
# RE_PRODUCTS = re.compile(r'"([^"]+)"\s*\((\d+(?:[,.]\d+)*).*\)')
# # Что мы ищем между кавычек? Всё, кроме кавычки. Разумеется, обособляем в группу.
# # Дальше допускаем ноль или несколько пробельных символов и ищем что-то между круглыми
# # скобками — их экранируем. Так как после цены товара может быть какой-то текст (например, валюта),
# # дописали “.*”. Особое внимание обращаем на то, как мы перехватываем цену: это может быть
# # целое число, а может быть вещественное: “(?:[,.]\d+)*” — поймает дробную часть, если она
# # будет. Тут снова видим спецсимвол ?: — попробуйте без него, результат изменится.
# txt = '''
# Иван сегодня сделал заказ: "iPhone 12" (158900,6 руб),
# "Galaxy S21"(98653.7 р).
# Позже он добавил в корзину "iPad"\t(32451)
# '''
#
# print(RE_PRODUCTS.findall(txt))

# Пример 4. найти в тексте слова, которые начинаются и заканчиваются на одну и ту же букву:

# import re
#
#
# RE_EQ_LETTERS = re.compile(r'\b(\w)\w*\1\b')
# txt = 'Однако, хорошо у вас получилось. А как еще могло быть?'
# print(RE_EQ_LETTERS.findall(txt))   # возвращает список совпадений с паттерном, если есть группы — возвращает их (как в нашем случае, вернул первые буквы слов);
# print(RE_EQ_LETTERS.search(txt))    # находит первое совпадение с паттерном и возвращает Match Object;
# print(RE_EQ_LETTERS.match(txt))     # работает аналогично .search(), но ищет с начала строки, а не по всей строке (очень часто их путают, в нашем случае ничего не нашёл);
# print(*RE_EQ_LETTERS.finditer(txt)) # по сути, работает как .search(), но в режиме итератора возвращает Match Object для всех совпадений (именно он нашёл все слова).

# import re
# RE_EQ_LETTERS = re.compile(r'\b(\w)\w*\1\b', re.IGNORECASE)   # флага re.IGNORECASE говорящее имя. При обработке многострочных текстов будет полезен флаг re.MULTILINE.
# txt = 'Однако, хорошо у вас получилось. А как еще могло быть?'
# print(*map(lambda x: x.group(0), RE_EQ_LETTERS.finditer(txt)), sep=', ')
# print(*RE_EQ_LETTERS.finditer(txt), sep=', ')


# # Пример 5. распарсить GET-данные в URL адресе в именованные группы
#
# import re
# RE_GET_PARSER = re.compile(r'(?<=[&?])(?P<key>[^&]+)=(?P<val>[^&]+)(?=&*)')
# url = 'https://translate.google.com/?hl=ru&sl=en&tl=ru&text=go&op=translate'
# print(*map(lambda x: x.groupdict(), RE_GET_PARSER.finditer(url)), sep=', ')
#
# # использовали здесь lookahead (взгляд вперёд) и lookbehind (взгляд
# # назад). То есть группа обособляется, если после неё или до неё есть определенный паттерн (в нашем
# # случае до группы [&?], а после — &*).